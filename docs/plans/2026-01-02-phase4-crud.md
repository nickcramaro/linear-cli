# Phase 4: Full CRUD Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add comment commands, document commands, and cross-entity search.

**Architecture:** Follow established patterns from Phases 2-3. Comments attach to issues. Documents belong to projects. Search queries across entities.

**Tech Stack:** Existing Rust stack

---

### Task 1: Add Comment Commands

**Files:**
- Create: `src/commands/comment.rs`
- Modify: `src/commands/mod.rs`
- Modify: `src/output.rs`
- Modify: `src/main.rs`

**Step 1: Create src/commands/comment.rs**

```rust
use clap::{Args, Subcommand};
use serde::Deserialize;

use crate::client::LinearClient;
use crate::error::Result;
use crate::output;

#[derive(Subcommand)]
pub enum CommentCommands {
    /// List comments on an issue
    List(ListCommentArgs),
    /// Create a comment on an issue
    Create(CreateCommentArgs),
}

#[derive(Args)]
pub struct ListCommentArgs {
    /// Issue ID (e.g., ENG-123)
    pub issue: String,
}

#[derive(Args)]
pub struct CreateCommentArgs {
    /// Issue ID (e.g., ENG-123)
    #[arg(long)]
    pub issue: String,

    /// Comment body (markdown supported)
    #[arg(long)]
    pub body: String,
}

#[derive(Deserialize)]
struct IssueCommentsResponse {
    issue: IssueWithComments,
}

#[derive(Deserialize)]
struct IssueWithComments {
    comments: CommentsConnection,
}

#[derive(Deserialize)]
struct CommentsConnection {
    nodes: Vec<Comment>,
}

#[derive(Deserialize, Clone)]
pub struct Comment {
    #[allow(dead_code)]
    pub id: String,
    pub body: String,
    #[serde(rename = "createdAt")]
    pub created_at: String,
    pub user: Option<CommentUser>,
}

#[derive(Deserialize, Clone)]
pub struct CommentUser {
    pub name: String,
}

#[derive(Deserialize)]
struct CreateCommentResponse {
    #[serde(rename = "commentCreate")]
    comment_create: CommentCreatePayload,
}

#[derive(Deserialize)]
struct CommentCreatePayload {
    success: bool,
}

const ISSUE_COMMENTS_QUERY: &str = r#"
    query IssueComments($id: String!) {
        issue(id: $id) {
            comments {
                nodes {
                    id
                    body
                    createdAt
                    user {
                        name
                    }
                }
            }
        }
    }
"#;

const CREATE_COMMENT_MUTATION: &str = r#"
    mutation CreateComment($input: CommentCreateInput!) {
        commentCreate(input: $input) {
            success
        }
    }
"#;

pub async fn handle_list(client: &LinearClient, args: &ListCommentArgs) -> Result<()> {
    let variables = serde_json::json!({ "id": args.issue });
    let response: IssueCommentsResponse = client.query(ISSUE_COMMENTS_QUERY, variables).await?;
    output::print_comments(&response.issue.comments.nodes);
    Ok(())
}

pub async fn handle_create(client: &LinearClient, args: &CreateCommentArgs) -> Result<()> {
    let input = serde_json::json!({
        "issueId": args.issue,
        "body": args.body
    });
    let variables = serde_json::json!({ "input": input });
    let response: CreateCommentResponse = client.query(CREATE_COMMENT_MUTATION, variables).await?;

    if response.comment_create.success {
        println!("Comment added.");
    } else {
        return Err(crate::error::Error::GraphQL("Failed to create comment".to_string()));
    }

    Ok(())
}
```

**Step 2: Add to src/commands/mod.rs**

```rust
pub mod comment;
```

Add to Commands enum:
```rust
/// Comment operations
Comment {
    #[command(subcommand)]
    command: comment::CommentCommands,
},
```

**Step 3: Add to src/output.rs**

```rust
use crate::commands::comment::Comment;

pub fn print_comments(comments: &[Comment]) {
    if comments.is_empty() {
        println!("No comments found.");
        return;
    }

    for comment in comments {
        let author = comment.user.as_ref().map(|u| u.name.as_str()).unwrap_or("Unknown");
        let date = &comment.created_at[..10];
        println!(
            "{} {}",
            author.if_supports_color(Stream::Stdout, |s| s.bold()),
            date.if_supports_color(Stream::Stdout, |s| s.dimmed())
        );
        println!("{}", comment.body);
        println!();
    }
}
```

**Step 4: Wire up in src/main.rs**

```rust
Commands::Comment { command } => match command {
    commands::comment::CommentCommands::List(args) => {
        commands::comment::handle_list(&client, &args).await?;
    }
    commands::comment::CommentCommands::Create(args) => {
        commands::comment::handle_create(&client, &args).await?;
    }
},
```

**Step 5: Verify and Commit**

```bash
cargo build
cargo clippy -- -D warnings
cargo fmt
git add -A
git commit -m "feat: add comment list and create commands"
```

---

### Task 2: Add Document Commands

**Files:**
- Create: `src/commands/document.rs`
- Modify: `src/commands/mod.rs`
- Modify: `src/output.rs`
- Modify: `src/main.rs`

**Step 1: Create src/commands/document.rs**

```rust
use clap::{Args, Subcommand};
use serde::Deserialize;

use crate::client::LinearClient;
use crate::error::Result;
use crate::output;

#[derive(Subcommand)]
pub enum DocumentCommands {
    /// List documents
    List(ListDocumentArgs),
    /// Get document details
    Get(GetDocumentArgs),
    /// Create a new document
    Create(CreateDocumentArgs),
}

#[derive(Args)]
pub struct ListDocumentArgs {
    /// Filter by project name or ID
    #[arg(long)]
    pub project: Option<String>,

    /// Maximum number to show
    #[arg(short = 'n', long, default_value = "25")]
    pub limit: u32,
}

#[derive(Args)]
pub struct GetDocumentArgs {
    /// Document ID
    pub id: String,
}

#[derive(Args)]
pub struct CreateDocumentArgs {
    /// Document title
    #[arg(long)]
    pub title: String,

    /// Project ID to attach document to
    #[arg(long)]
    pub project: String,

    /// Document content (markdown)
    #[arg(long)]
    pub content: Option<String>,
}

#[derive(Deserialize)]
struct DocumentsResponse {
    documents: DocumentsConnection,
}

#[derive(Deserialize)]
struct DocumentsConnection {
    nodes: Vec<Document>,
}

#[derive(Deserialize, Clone)]
pub struct Document {
    pub id: String,
    pub title: String,
    #[serde(rename = "updatedAt")]
    pub updated_at: String,
}

#[derive(Deserialize)]
struct DocumentResponse {
    document: DocumentDetail,
}

#[derive(Deserialize)]
pub struct DocumentDetail {
    pub id: String,
    pub title: String,
    pub content: Option<String>,
    #[serde(rename = "createdAt")]
    pub created_at: String,
    #[serde(rename = "updatedAt")]
    pub updated_at: String,
}

#[derive(Deserialize)]
struct CreateDocumentResponse {
    #[serde(rename = "documentCreate")]
    document_create: DocumentCreatePayload,
}

#[derive(Deserialize)]
struct DocumentCreatePayload {
    success: bool,
    document: Option<CreatedDocument>,
}

#[derive(Deserialize)]
struct CreatedDocument {
    id: String,
    title: String,
}

const DOCUMENTS_QUERY: &str = r#"
    query Documents($first: Int, $filter: DocumentFilter) {
        documents(first: $first, filter: $filter) {
            nodes {
                id
                title
                updatedAt
            }
        }
    }
"#;

const DOCUMENT_QUERY: &str = r#"
    query Document($id: String!) {
        document(id: $id) {
            id
            title
            content
            createdAt
            updatedAt
        }
    }
"#;

const CREATE_DOCUMENT_MUTATION: &str = r#"
    mutation CreateDocument($input: DocumentCreateInput!) {
        documentCreate(input: $input) {
            success
            document {
                id
                title
            }
        }
    }
"#;

pub async fn handle_list(client: &LinearClient, args: &ListDocumentArgs) -> Result<()> {
    let mut filter = serde_json::Map::new();
    if let Some(project) = &args.project {
        filter.insert("project".to_string(), serde_json::json!({ "id": { "eq": project } }));
    }

    let variables = serde_json::json!({
        "first": args.limit,
        "filter": filter
    });

    let response: DocumentsResponse = client.query(DOCUMENTS_QUERY, variables).await?;
    output::print_documents(&response.documents.nodes);
    Ok(())
}

pub async fn handle_get(client: &LinearClient, args: &GetDocumentArgs) -> Result<()> {
    let variables = serde_json::json!({ "id": args.id });
    let response: DocumentResponse = client.query(DOCUMENT_QUERY, variables).await?;
    output::print_document_detail(&response.document);
    Ok(())
}

pub async fn handle_create(client: &LinearClient, args: &CreateDocumentArgs) -> Result<()> {
    let mut input = serde_json::Map::new();
    input.insert("title".to_string(), serde_json::json!(args.title));
    input.insert("projectId".to_string(), serde_json::json!(args.project));

    if let Some(content) = &args.content {
        input.insert("content".to_string(), serde_json::json!(content));
    }

    let variables = serde_json::json!({ "input": input });
    let response: CreateDocumentResponse = client.query(CREATE_DOCUMENT_MUTATION, variables).await?;

    if response.document_create.success {
        if let Some(doc) = response.document_create.document {
            println!("Created document: {}", doc.title);
            println!("ID: {}", doc.id);
        }
    } else {
        return Err(crate::error::Error::GraphQL("Failed to create document".to_string()));
    }

    Ok(())
}
```

**Step 2: Add output functions to src/output.rs**

```rust
use crate::commands::document::{Document, DocumentDetail};

pub fn print_documents(documents: &[Document]) {
    if documents.is_empty() {
        println!("No documents found.");
        return;
    }

    for doc in documents {
        println!(
            "{} {}",
            doc.title.if_supports_color(Stream::Stdout, |s| s.bold()),
            doc.updated_at[..10].if_supports_color(Stream::Stdout, |s| s.dimmed())
        );
    }
}

pub fn print_document_detail(doc: &DocumentDetail) {
    println!("{}", doc.title.if_supports_color(Stream::Stdout, |s| s.bold()));
    println!();
    println!(
        "{}: {}",
        "Created".if_supports_color(Stream::Stdout, |s| s.dimmed()),
        &doc.created_at[..10]
    );
    println!(
        "{}: {}",
        "Updated".if_supports_color(Stream::Stdout, |s| s.dimmed()),
        &doc.updated_at[..10]
    );

    if let Some(content) = &doc.content {
        if !content.is_empty() {
            println!();
            println!("{}", content);
        }
    }
}
```

**Step 3: Wire up and commit**

```bash
git commit -m "feat: add document list, get, and create commands"
```

---

### Task 3: Add Search Command

**Files:**
- Create: `src/commands/search.rs`
- Modify: `src/commands/mod.rs`
- Modify: `src/output.rs`
- Modify: `src/main.rs`

**Step 1: Create src/commands/search.rs**

```rust
use clap::Args;
use serde::Deserialize;

use crate::client::LinearClient;
use crate::error::Result;
use crate::output;

#[derive(Args)]
pub struct SearchArgs {
    /// Search query
    pub query: String,

    /// Maximum results
    #[arg(short = 'n', long, default_value = "10")]
    pub limit: u32,
}

#[derive(Deserialize)]
struct SearchResponse {
    #[serde(rename = "searchIssues")]
    search_issues: SearchConnection,
}

#[derive(Deserialize)]
struct SearchConnection {
    nodes: Vec<SearchResult>,
}

#[derive(Deserialize, Clone)]
pub struct SearchResult {
    pub id: String,
    pub identifier: String,
    pub title: String,
    pub state: Option<SearchState>,
}

#[derive(Deserialize, Clone)]
pub struct SearchState {
    pub name: String,
}

const SEARCH_QUERY: &str = r#"
    query SearchIssues($query: String!, $first: Int) {
        searchIssues(query: $query, first: $first) {
            nodes {
                id
                identifier
                title
                state {
                    name
                }
            }
        }
    }
"#;

pub async fn handle_search(client: &LinearClient, args: &SearchArgs) -> Result<()> {
    let variables = serde_json::json!({
        "query": args.query,
        "first": args.limit
    });

    let response: SearchResponse = client.query(SEARCH_QUERY, variables).await?;
    output::print_search_results(&response.search_issues.nodes);
    Ok(())
}
```

**Step 2: Add to mod.rs as a top-level command**

```rust
pub mod search;
```

Add to Commands enum:
```rust
/// Search issues
Search(search::SearchArgs),
```

**Step 3: Add to output.rs**

```rust
use crate::commands::search::SearchResult;

pub fn print_search_results(results: &[SearchResult]) {
    if results.is_empty() {
        println!("No results found.");
        return;
    }

    for result in results {
        let state = result.state.as_ref().map(|s| s.name.as_str()).unwrap_or("â€”");
        println!(
            "{} {} [{}]",
            result.identifier.if_supports_color(Stream::Stdout, |s| s.cyan().bold()),
            result.title,
            state
        );
    }
}
```

**Step 4: Wire up in main.rs**

```rust
Commands::Search(args) => {
    commands::search::handle_search(&client, &args).await?;
}
```

**Step 5: Commit**

```bash
git commit -m "feat: add search command"
```

---

### Task 4: Final Verification and Cleanup

**Step 1:** Run clippy and fmt
**Step 2:** Build release
**Step 3:** Verify all new commands show help
**Step 4:** Commit cleanup

---

## Summary

After completing all tasks:

- `linear comment list <issue>` / `linear comment create --issue <id> --body "text"`
- `linear document list` / `linear document get <id>` / `linear document create`
- `linear search "query"`

**Next Phase:** Phase 5 - Polish (--json flag, shell completions, man pages).
